# Kociemba 格式分析

## 官方文档要点

根据 [Kociemba GitHub README](https://raw.githubusercontent.com/muodov/kociemba/blob/master/README.md)：

### 1. Cubestring 格式

**顺序**：`U1, U2, U3, U4, U5, U6, U7, U8, U9, R1, R2, R3, R4, R5, R6, R7, R8, R9, F1, F2, F3, F4, F5, F6, F7, F8, F9, D1, D2, D3, D4, D5, D6, D7, D8, D9, L1, L2, L3, L4, L5, L6, L7, L8, L9, B1, B2, B3, B4, B5, B6, B7, B8, B9`

**已解决状态**：`UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB`

### 2. 面的布局

```
             |************|
             |*U1**U2**U3*|
             |************|
             |*U4**U5**U6*|
             |************|
             |*U7**U8**U9*|
             |************|
 ************|************|************|************
 *L1**L2**L3*|*F1**F2**F3*|*R1**R2**R3*|*B1**B2**B3*
 ************|************|************|************
 *L4**L5**L6*|*F4**F5**F6*|*R4**R5**R6*|*B4**B5**B6*
 ************|************|************|************
 *L7**L8**L9*|*F7**F8**F9*|*R7**R8**R9*|*B7**B8**B9*
 ************|************|************|************
             |************|
             |*D1**D2**D3*|
             |************|
             |*D4**D5**D6*|
             |************|
             |*D7**D8**D9*|
             |************|
```

### 3. 关键发现

**每个面都是标准的行优先顺序（row-major order）**：
- 第一行：位置 0-2 (U1-U3, R1-R3, F1-F3, D1-D3, L1-L3, B1-B3)
- 第二行：位置 3-5 (U4-U6, R4-R6, F4-F6, D4-D6, L4-L6, B4-B6)
- 第三行：位置 6-8 (U7-U9, R7-R9, F7-F9, D7-D9, L7-L9, B7-B9)
- 中心块：位置 4 (第二行第二列)

## 与现有实现的冲突

### 我们的实现问题

在 `cubeStateToCubestring` 函数中：

1. **U面**：`row=2到0`（反向读取行）❌
   - 官方文档：标准行优先顺序 `row=0到2`
   - **冲突**：我们反向读取了行

2. **D面**：`row=2到0`（反向读取行）❌
   - 官方文档：标准行优先顺序 `row=0到2`
   - **冲突**：我们反向读取了行

3. **B面**：`row=0到2, col=2到0`（反向读取列）❌
   - 官方文档：标准行优先顺序 `row=0到2, col=0到2`
   - **冲突**：我们反向读取了列

4. **R面、F面、L面**：`row=0到2, col=0到2`（标准顺序）✅
   - 与官方文档一致

### 根本原因

我们的实现试图根据内部坐标系统（`RubiksCube.tsx`）的特殊映射来调整读取顺序，但**Kociemba 要求每个面都是标准的行优先顺序**，不需要根据视角调整。

## 解决方案

需要修改 `cubeStateToCubestring` 函数，使所有面都使用标准的行优先顺序：

```typescript
// 所有面都应该使用标准顺序
for (let row = 0; row < 3; row++) {
  for (let col = 0; col < 3; col++) {
    cubestring += colorToKociembaChar(cubeState.FACE[row][col])
  }
}
```

但是，这需要确保我们的内部坐标系统与 Kociemba 的坐标系统一致，或者需要调整坐标映射。

## 注意事项

1. **已解决状态问题**（已解决）：官方文档中的已解决状态 `UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB` 返回的解决方案 `R L U2 R L' B2 U2 R2 F2 L2 D2 L2 F2` 实际上是一组恒等变换（转一圈然后又还原），所以这个问题可以暂时忽略。Kociemba 可能对已解决状态返回恒等变换序列而不是空字符串，这是库的实现细节。

2. **坐标系统映射**：我们的内部坐标系统（`RubiksCube.tsx`）可能与 Kociemba 的坐标系统不一致，需要仔细检查每个面的 row/col 映射。

3. **测试验证**：修复后需要使用已知有效的 cubestring 进行测试验证。
